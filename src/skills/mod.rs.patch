--- a/src/skills/mod.rs
+++ b/src/skills/mod.rs
@@ -73,38 +73,45 @@ fn default_version() -> String {
 
 /// Load all skills from the workspace skills directory
 pub fn load_skills(workspace_dir: &Path) -> Vec<Skill> {
-    load_skills_with_open_skills_config(workspace_dir, None, None)
+    load_skills_with_open_skills_config(workspace_dir, None, None, false)
 }
 
 /// Load skills using runtime config values (preferred at runtime).
 pub fn load_skills_with_config(workspace_dir: &Path, config: &crate::config::Config) -> Vec<Skill> {
     load_skills_with_open_skills_config(
         workspace_dir,
         Some(config.skills.open_skills_enabled),
         config.skills.open_skills_dir.as_deref(),
+        config.skills.skip_security_audit,
     )
 }
 
 fn load_skills_with_open_skills_config(
     workspace_dir: &Path,
     config_open_skills_enabled: Option<bool>,
     config_open_skills_dir: Option<&str>,
+    skip_audit: bool,
 ) -> Vec<Skill> {
     let mut skills = Vec::new();
 
     if let Some(open_skills_dir) =
         ensure_open_skills_repo(config_open_skills_enabled, config_open_skills_dir)
     {
-        skills.extend(load_open_skills(&open_skills_dir));
+        skills.extend(load_open_skills(&open_skills_dir, skip_audit));
     }
 
-    skills.extend(load_workspace_skills(workspace_dir));
+    skills.extend(load_workspace_skills(workspace_dir, skip_audit));
     skills
 }
 
-fn load_workspace_skills(workspace_dir: &Path) -> Vec<Skill> {
+fn load_workspace_skills(workspace_dir: &Path, skip_audit: bool) -> Vec<Skill> {
     let skills_dir = workspace_dir.join("skills");
-    load_skills_from_directory(&skills_dir)
+    load_skills_from_directory(&skills_dir, skip_audit)
 }
 
-fn load_skills_from_directory(skills_dir: &Path) -> Vec<Skill> {
+fn load_skills_from_directory(skills_dir: &Path, skip_audit: bool) -> Vec<Skill> {
     if !skills_dir.exists() {
         return Vec::new();
     }
@@ -124,23 +131,31 @@ fn load_skills_from_directory(skills_dir: &Path) -> Vec<Skill> {
             continue;
         }
 
-        match audit::audit_skill_directory(&path) {
-            Ok(report) if report.is_clean() => {}
-            Ok(report) => {
-                tracing::warn!(
-                    "skipping insecure skill directory {}: {}",
-                    path.display(),
-                    report.summary()
-                );
-                continue;
-            }
-            Err(err) => {
-                tracing::warn!(
-                    "skipping unauditable skill directory {}: {err}",
-                    path.display()
-                );
-                continue;
+        if !skip_audit {
+            match audit::audit_skill_directory(&path) {
+                Ok(report) if report.is_clean() => {}
+                Ok(report) => {
+                    tracing::warn!(
+                        "skipping insecure skill directory {}: {}",
+                        path.display(),
+                        report.summary()
+                    );
+                    continue;
+                }
+                Err(err) => {
+                    tracing::warn!(
+                        "skipping unauditable skill directory {}: {err}",
+                        path.display()
+                    );
+                    continue;
+                }
             }
         }
 
@@ -161,13 +176,13 @@ fn load_skills_from_directory(skills_dir: &Path) -> Vec<Skill> {
     skills
 }
 
-fn load_open_skills(repo_dir: &Path) -> Vec<Skill> {
+fn load_open_skills(repo_dir: &Path, skip_audit: bool) -> Vec<Skill> {
     // Modern open-skills layout stores skill packages in `skills/<name>/SKILL.md`.
     // Prefer that structure to avoid treating repository docs (e.g. CONTRIBUTING.md)
     // as executable skills.
     let nested_skills_dir = repo_dir.join("skills");
     if nested_skills_dir.is_dir() {
-        return load_skills_from_directory(&nested_skills_dir);
+        return load_skills_from_directory(&nested_skills_dir, skip_audit);
     }
 
     let mut skills = Vec::new();
@@ -198,23 +213,31 @@ fn load_open_skills(repo_dir: &Path) -> Vec<Skill> {
             continue;
         }
 
-        match audit::audit_open_skill_markdown(&path, repo_dir) {
-            Ok(report) if report.is_clean() => {}
-            Ok(report) => {
-                tracing::warn!(
-                    "skipping insecure open-skill file {}: {}",
-                    path.display(),
-                    report.summary()
-                );
-                continue;
-            }
-            Err(err) => {
-                tracing::warn!(
-                    "skipping unauditable open-skill file {}: {err}",
-                    path.display()
-                );
-                continue;
+        if !skip_audit {
+            match audit::audit_open_skill_markdown(&path, repo_dir) {
+                Ok(report) if report.is_clean() => {}
+                Ok(report) => {
+                    tracing::warn!(
+                        "skipping insecure open-skill file {}: {}",
+                        path.display(),
+                        report.summary()
+                    );
+                    continue;
+                }
+                Err(err) => {
+                    tracing::warn!(
+                        "skipping unauditable open-skill file {}: {err}",
+                        path.display()
+                    );
+                    continue;
+                }
             }
         }
 
@@ -709,13 +732,18 @@ fn detect_newly_installed_directory(
     }
 }
 
-fn enforce_skill_security_audit(skill_path: &Path) -> Result<audit::SkillAuditReport> {
+fn enforce_skill_security_audit(skill_path: &Path, skip_audit: bool) -> Result<audit::SkillAuditReport> {
+    if skip_audit {
+        // Return a clean report without actually auditing
+        return Ok(audit::SkillAuditReport::default());
+    }
     let report = audit::audit_skill_directory(skill_path)?;
     if report.is_clean() {
         return Ok(report);
     }
 
     anyhow::bail!("Skill security audit failed: {}", report.summary());
 }
 
@@ -772,7 +800,7 @@ fn copy_dir_recursive_secure(src: &Path, dest: &Path) -> Result<()> {
     Ok(())
 }
 
-fn install_local_skill_source(source: &str, skills_path: &Path) -> Result<(PathBuf, usize)> {
+fn install_local_skill_source(source: &str, skills_path: &Path, skip_audit: bool) -> Result<(PathBuf, usize)> {
     let source_path = PathBuf::from(source);
     if !source_path.exists() {
         anyhow::bail!("Source path does not exist: {source}");
@@ -781,7 +809,7 @@ fn install_local_skill_source(source: &str, skills_path: &Path) -> Result<(PathB
     let source_path = source_path
         .canonicalize()
         .with_context(|| format!("failed to canonicalize source path {source}"))?;
-    let _ = enforce_skill_security_audit(&source_path)?;
+    let _ = enforce_skill_security_audit(&source_path, skip_audit)?;
 
     let name = source_path
         .file_name()
@@ -796,7 +824,7 @@ fn install_local_skill_source(source: &str, skills_path: &Path) -> Result<(PathB
         return Err(err);
     }
 
-    match enforce_skill_security_audit(&dest) {
+    match enforce_skill_security_audit(&dest, skip_audit) {
         Ok(report) => Ok((dest, report.files_scanned)),
         Err(err) => {
             let _ = std::fs::remove_dir_all(&dest);
@@ -805,7 +833,7 @@ fn install_local_skill_source(source: &str, skills_path: &Path) -> Result<(PathB
     }
 }
 
-fn install_git_skill_source(source: &str, skills_path: &Path) -> Result<(PathBuf, usize)> {
+fn install_git_skill_source(source: &str, skills_path: &Path, skip_audit: bool) -> Result<(PathBuf, usize)> {
     let before = snapshot_skill_children(skills_path)?;
     let output = std::process::Command::new("git")
         .args(["clone", "--depth", "1", source])
@@ -818,7 +846,7 @@ fn install_git_skill_source(source: &str, skills_path: &Path) -> Result<(PathBuf
 
     let installed_dir = detect_newly_installed_directory(skills_path, &before)?;
     remove_git_metadata(&installed_dir)?;
-    match enforce_skill_security_audit(&installed_dir) {
+    match enforce_skill_security_audit(&installed_dir, skip_audit) {
         Ok(report) => Ok((installed_dir, report.files_scanned)),
         Err(err) => {
             let _ = std::fs::remove_dir_all(&installed_dir);
@@ -911,7 +939,7 @@ pub fn handle_command(command: crate::SkillCommands, config: &crate::config::Con
 
             if is_git_source(&source) {
                 let (installed_dir, files_scanned) =
-                    install_git_skill_source(&source, &skills_path)
+                    install_git_skill_source(&source, &skills_path, config.skills.skip_security_audit)
                         .with_context(|| format!("failed to install git skill source: {source}"))?;
                 println!(
                     "  {} Skill installed and audited: {} ({} files scanned)",
@@ -920,7 +948,7 @@ pub fn handle_command(command: crate::SkillCommands, config: &crate::config::Con
                     files_scanned
                 );
             } else {
-                let (dest, files_scanned) = install_local_skill_source(&source, &skills_path)
+                let (dest, files_scanned) = install_local_skill_source(&source, &skills_path, config.skills.skip_security_audit)
                     .with_context(|| format!("failed to install local skill source: {source}"))?;
                 println!(
                     "  {} Skill installed and audited: {} ({} files scanned)",
